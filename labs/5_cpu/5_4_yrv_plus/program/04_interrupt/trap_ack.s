.section .text.trap_ack
.global trap_ack

.equ  mie,    0x304
.equ  mtvec,  0x305
.equ  mcause, 0x342
.equ  iobase, 0xffff0     # i/o at 0xffff0000

trap_ack:
    csrr  t2, mcause           # Читаем причину прерывания (mcause)
    bltz  t2, handle_exception # Если причина отрицательная, это исключение, не прерывание

    # Если положительное, значит это прерывание
    srli  t2, t2, 1            # Удаляем старший бит, чтобы прочитать номер прерывания
    li    t1, 0x16             # Проверяем прерывание по маске (EINT, ECALL)
    bne   t1, t2, check_other  # Если не совпадают, переходим к проверке других

    # Если маска совпала, значит это прерывание EINT
    # Здесь можно добавить специальную обработку для EINT
    j common_return            # Переходим к общему возврату

check_other:
    li    t1, 0x20             # Проверяем другое возможное прерывание (например, Local Interrupt)
    bltu  t2, t1, unknown      # Если значение меньше 0x20, то считаем его неизвестным

    # Далее можно добавлять обработку для других известных прерываний
    # Например, обработка для Local Interrupt
    # ...

common_return:
    mret                      # Завершаем обработку прерывания и возвращаемся в основную программу

handle_exception:
    # Специфичная обработка исключения (если нужны специальные действия)
    mret                      # Завершаем обработку исключения и возвращаемся в основную программу

unknown:
    # Специфичная обработка неизвестного прерывания
    mret

